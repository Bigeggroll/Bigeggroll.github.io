{"meta":{"title":"Bigeggroll","subtitle":null,"description":"java学习","author":"孔伟","url":"http://www.bigeggroll.work","root":"/"},"pages":[],"posts":[{"title":"JDK1.8后的新特性","slug":"JDK1.8后的新特性","date":"2019-01-23T13:02:30.000Z","updated":"2019-09-26T08:39:45.573Z","comments":true,"path":"2019/01/23/JDK1.8后的新特性/","link":"","permalink":"http://www.bigeggroll.work/2019/01/23/JDK1.8后的新特性/","excerpt":"","text":"JDK1.8后的新特性 在jdk1.8中对hashMap等map集合的数据结构优化。 ​ 原来的hashMap采用的数据结构是哈希表（数组+链表），hashMap默认大小是16，一个0-15索引的数组，如何往里面存储元素，首先调用元素的hashcode方法，计算出哈希码值，经过哈希算法算成数组的索引值，如果对应的索引处没有元素，直接存放，如果有对象在，那么比较它们的equals方法比较内容 ,如果内容一样，后一个value会将前一个value的值覆盖，如果不一样，在1.7的时候，后加的放在前面，形成一个链表，形成了碰撞，在某些情况下如果链表无限下去，那么效率极低，碰撞是避免不了的 ,加载因子：0.75，数组扩容，达到总容量的75%，就进行扩容，但是无法避免碰撞的情况发生,在1.8之后，在数组+链表+红黑树来实现hashmap，当碰撞的元素个数大于8时 &amp; 总容量大于64，会有红黑树的引入,除了添加之后，效率都比链表高，1.8之后链表新进元素加到末尾,ConcurrentHashMap (锁分段机制)，concurrentLevel,jdk1.8采用CAS算法(无锁算法，不再使用锁分段)，数组+链表中也引入了红黑树的使用 ###Lambda表达式 先初步的了解一下lambda表达式的应用场景 123456789101112//使用匿名内部内调用线程new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"来啦老弟\"); &#125;&#125;).start();//使用lambda表达式重写run方法并调用线程new Thread(() -&gt; &#123; System.out.println(\"来啦小老弟\");&#125;).start(); ####匿名内部类简化了实现类和子类的编写，使用Lambda表达式简化了部分匿名内部类的编写。 Lambda表达式的格式： 123456格式 ：(方法的参数列表)-&gt;&#123;方法体&#125;（形式参数）：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可-&gt; : 由英文中画线和大于符号组成，固定写法。代表指向动作&#123;代码块&#125; ：是我们具体要做的事情，也就是以前我们写的方法体内容组成Lambda表达式的三要素： 形式参数，箭头，代码块 Lambda表达式用于自定义的类的用法 Lambda表达式用于无参数的情况 123456789101112131415161718192021public interface EatAble &#123; void eat();&#125;public class LambdaDemo &#123; public static void main(String[] args) &#123; //使用匿名内部内调用eat方法 eatAble(new EatAble() &#123; @Override public void eat() &#123; System.out.println(\"吃大苹果\"); &#125; &#125;); //使用lambda表达式重写eat方法并调用 eatAble(() -&gt;&#123; System.out.println(\"吃苹果\"); &#125;); &#125; public static void eatAble(EatAble e)&#123; e.eat(); &#125;&#125; Lambda表达式用于有参数的情况 1234567891011121314151617181920public interface Fly &#123; void fly(String s);&#125;//匿名内部内flyAble(new Fly() &#123; @Override public void fly(String s) &#123; System.out.println(s); System.out.println(\"飞机起飞了\"); &#125;&#125;);//有参的lambda表达式flyAble((String s)-&gt;&#123; System.out.println(s); System.out.println(\"飞机又起飞了\");&#125;);public static void flyAble(Fly f)&#123; f.fly(\"开飞机喽\");&#125; Lambda表达式用于有参数有返回值的情况 12345678910111213141516171819public interface AddAble &#123; int add(int a,int b);&#125;addAble(new AddAble() &#123; @Override public int add(int a, int b) &#123; return a+b; &#125;&#125;);//lambda有参有返回值类型addAble((int a,int b) -&gt;&#123; return a+b;&#125;);public static void addAble(AddAble a)&#123; int i = a.add(2, 3); System.out.println(i);&#125; 以上是Lambda基础的用法，Lambda还能够更加的简化，可以根据不同的情况进行简化 简化规则： 参数类型可以省略。但是有多个参数的情况下，不能只省略一个 如果参数有且仅有一个，那么小括号可以省略 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字 1234567891011121314151617181920212223public interface EatAble &#123; void eat();&#125;public interface Fly &#123; void fly(String s);&#125;addAble((int a,int b) -&gt;&#123; return a+b;&#125;);//参数的类型可以省略 useAddable((x, y) -&gt; &#123; return x + y; &#125;);useFlyable((String s) -&gt; &#123; System.out.println(s); &#125;);//如果参数有且仅有一个，那么小括号可以省略 useFlyable(s -&gt; &#123; System.out.println(s); &#125;);//如果代码块的语句只有一条，可以省略大括号和分号 useFlyable(s -&gt; System.out.println(s));//如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 useAddable((x, y) -&gt; x + y); Lambda表达式的注意事项​ 使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法 ​ 必须有上下文环境，才能推导出Lambda对应的接口 根据局部变量的赋值得知Lambda对应的接口 Runnable r = () -&gt; System.out.println(“Lambda表达式”); 根据调用方法的参数得知Lambda对应的接口 new Thread(() -&gt; System.out.println(“Lambda表达式”)).start(); Lambda表达式和匿名内部类的区别 所需类型不同 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 实现原理不同 匿名内部类：编译之后，产生一个单独的.class字节码文件 Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时 候动态生成 接口接口组成更新概述1. 常量 public static final 2. 抽象方法 public abstract 3. 默认方法(Java 8) 4. 静态方法(Java 8) 5. 私有方法(Java 9)接口中默认方法12格式 public default 返回值类型 方法名(参数列表) &#123; &#125; 注意事项 默认方法不是抽象方法，所不以强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 接口中静态方法12格式public static 返回值类型 方法名(参数列表) &#123; &#125; 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 接口中私有方法私有方法产生原因 ​ Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的 默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实 现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用 私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 1234格式1private 返回值类型 方法名(参数列表) &#123; &#125; 格式2private static 返回值类型 方法名(参数列表) &#123; &#125; 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 方法引用方法引用的出现原因 ​ 在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作 那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再 写重复逻辑呢？答案肯定是没有必要 那我们又是如何使用已经存在的方案的呢？ 这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案 代码演示 123456789101112131415161718public interface Printable &#123; void printString(String s); &#125; public class PrintableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用usePrintable方法 // usePrintable((String s) -&gt; &#123; // System.out.println(s); // &#125;); //Lambda简化写法 usePrintable(s -&gt; System.out.println(s)); //方法引用 usePrintable(System.out::println); &#125; private static void usePrintable(Printable p) &#123; p.printString(\"来啦\"); &#125; &#125; 方法引用符 :: 该符号为引用运算符，而它所在的表达式被称为方法引用 推导与省略 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载 形式， 它们都将被自动推导 如果使用方法引用，也是同样可以根据上下文进行推导 方法引用是Lambda的孪生兄弟 引用类方法 ​ 引用类方法，其实就是引用类的静态方法 格式 ​ 类名::静态方法 ​ 范例 ：Integer::parseInt ​ Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据 123456789101112131415public interface Converter &#123; int convert(String s); &#125; public class ConverterDemo &#123; public static void main(String[] args) &#123; //Lambda写法 useConverter(s -&gt; Integer.parseInt(s)); //引用类方法 useConverter(Integer::parseInt); &#125; private static void useConverter(Converter c) &#123; int number = c.convert(\"666\"); System.out.println(number); &#125; &#125; 使用说明 Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数 引用对象的实例方法 引用对象的实例方法，其实就引用类中的成员方法 格式 ​ 对象::成员方法 范例 ​ “HelloWorld”::toUpperCase ​ String类中的方法：public String toUpperCase() 将此String所有字符转换为大写 12345678910111213141516171819202122public class PrintString &#123; //把字符串参数变成大写的数据，然后在控制台输出 public void printUpper(String s) &#123; String result = s.toUpperCase(); System.out.println(result); &#125; &#125;public interface Printer &#123; void printUpperCase(String s); &#125; public class PrinterDemo &#123; public static void main(String[] args) &#123; //Lambda简化写法 usePrinter(s -&gt; System.out.println(s.toUpperCase())); //引用对象的实例方法 PrintString ps = new PrintString(); usePrinter(ps::printUpper); &#125; private static void usePrinter(Printer p) &#123; p.printUpperCase(\"HelloWorld\"); &#125; &#125; 使用说明 Lambda表达式被对象的实例方法替代的时候，它的形式参数全部传递给该方法作为参数 引用类的实例方法 引用类的实例方法，其实就是引用类中的成员方法 格式 ​ 类名::成员方法 范例 ​ String::substring public String substring(int beginIndex,int endIndex) ​ 从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex 12345678910111213public interface MyString &#123; String mySubString(String s,int x,int y); &#125;public class MyS tringDemo &#123; public static void main(String[] args) &#123; //Lambda简化写法 useMyString((s,x,y) -&gt; s.substring(x,y)); //引用类的实例方法 useMyString(String::substring); &#125; private static void useMyString(MyString my) &#123; String s = my.mySubString(\"HelloWorld\", 2, 5); System.out.println(s); &#125; &#125; 使用说明 Lambda表达式被类的实例方法替代的时候 第一个参数作为调用者 后面的参数全部传递给该方法作为参数 引用构造器 引用构造器，其实就是引用构造方法 格式 ​ 类名::new 范例 ：Student::new 123456789101112131415public interface StudentBuilder &#123; Student build(String name,int age); &#125; public class StudentDemo &#123; public static void main(String[] args) &#123; //Lambda简化写法 useStudentBuilder((name,age) -&gt; new Student(name,age)); //引用构造器 useStudentBuilder(Student::new); &#125; private static void useStudentBuilder(StudentBuilder sb) &#123; Student s = sb.build(\"林青霞\", 30); System.out.println(s.getName() + \",\" + s.getAge()); &#125; &#125; 使用说明 Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数","categories":[],"tags":[]},{"title":"servlet绘制验证码","slug":"servlet绘制验证码","date":"2019-01-09T10:34:30.000Z","updated":"2019-09-26T08:39:14.056Z","comments":true,"path":"2019/01/09/servlet绘制验证码/","link":"","permalink":"http://www.bigeggroll.work/2019/01/09/servlet绘制验证码/","excerpt":"","text":"###servlet在线生成验证码 ####初步生成版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package work.eggroll.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/访问路径\")public class CheckCodeServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.black); g.drawRect(0,0,width - 1,height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生成随机角标 Random ran = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= 4; i++) &#123; int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 sb.append(ch); //2.3写验证码 g.drawString(ch+\"\",width/5*i,height/2); &#125; //2.4画干扰线 g.setColor(Color.red); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; //3.将图片输出到页面展示 ImageIO.write(image,\"jpg\",response.getOutputStream()); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; ####加强版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package work.eggroll.web.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * 生成验证码图片 * * */@WebServlet(\"/访问路径\")public class CheckCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; int width = 130; int height = 35; // 步骤一 绘制一张内存中图片 BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // 步骤二 图片绘制背景颜色 ---通过绘图对象 Graphics graphics = bufferedImage.getGraphics();// 得到画图对象 --- 画笔 // 绘制任何图形之前 都必须指定一个颜色 graphics.setColor(getRandColor(200, 250)); graphics.fillRect(0, 0, width, height); // 步骤三 绘制边框 graphics.setColor(Color.WHITE); graphics.drawRect(0, 0, width - 1, height - 1); // 步骤四 四个随机数字 Graphics2D graphics2d = (Graphics2D) graphics; // 设置输出字体 graphics2d.setFont(new Font(\"宋体\", Font.BOLD, 28)); String words =\"0123456789\"; String operators=\"+-*\"; Random random = new Random();// 生成随机数 //定义StringBuilder拼接验证码字符 StringBuilder sBuilder=new StringBuilder(); // 定义x坐标 int x = 10; //定义数组保存生成的数字，后面计算结果使用 int[] nums=new int[2]; //定义变量保存运算符，后面计算结果使用 String operator=\"\"; for (int i = 0; i &lt; 2; i++) &#123; // 随机颜色 graphics2d.setColor(new Color(20 + random.nextInt(110), 20 + random .nextInt(110), 20 + random.nextInt(110))); // 旋转 -30 --- 30度 int jiaodu = random.nextInt(60) - 30; // 换算弧度 double theta = jiaodu * Math.PI / 180; // 生成一个随机数字 int index = random.nextInt(words.length()); // 生成随机数 0 到 length - 1 // 获得数字 char c = words.charAt(index); //保存到数组中,后面计算结果用 nums[i]=Integer.parseInt(c+\"\"); //拼接字符 sBuilder.append(c); // 将c 输出到图片 graphics2d.rotate(theta, x, 20); graphics2d.drawString(String.valueOf(c), x, 25); graphics2d.rotate(-theta, x, 20); x += 30; //生成运算符 if(i==0)&#123; // 生成一个随机数字 index = random.nextInt(operators.length()); // 生成随机数 0 到 length - 1 // 获得运算符 operator = operators.charAt(index)+\"\"; //拼接字符 sBuilder.append(operator); // 将c 输出到图片 graphics2d.drawString(operator, x, 25); &#125;else&#123; //拼接=号 sBuilder.append(\"=\"); // 将c 输出到图片 graphics2d.drawString(\"=\", x, 25); &#125; x += 30; &#125; //计算结果 int result=0; if(\"+\".equals(operator))&#123; result=nums[0]+nums[1]; &#125;else if(\"-\".equals(operator))&#123; result=nums[0]-nums[1]; &#125;else&#123; result=nums[0]*nums[1]; &#125; //控制台打印验证码和计算结果 System.out.println(nums[0]+operator+nums[1]+\"=\"+result); // 步骤五 绘制干扰线 graphics.setColor(getRandColor(160, 200)); int x1; int x2; int y1; int y2; for (int i = 0; i &lt; 30; i++) &#123; x1 = random.nextInt(width); x2 = random.nextInt(12); y1 = random.nextInt(height); y2 = random.nextInt(12); graphics.drawLine(x1, y1, x1 + x2, x2 + y2); &#125; // 将上面图片输出到浏览器 ImageIO graphics.dispose();// 释放资源 ImageIO.write(bufferedImage, \"jpg\", response.getOutputStream()); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; /** * 取其某一范围的color * * @param fc * int 范围参数1 * @param bc * int 范围参数2 * @return Color */ private Color getRandColor(int fc, int bc) &#123; // 取其随机颜色 Random random = new Random(); if (fc &gt; 255) &#123; fc = 255; &#125; if (bc &gt; 255) &#123; bc = 255; &#125; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125;&#125; 改良版使用10以内的加减法，避免用太大的数计算导致计算量过大","categories":[],"tags":[]}]}